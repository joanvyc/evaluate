#!/bin/bash

function declare_colors {
    RED='\033[1;31m'
    GREEN='\033[1;32m'
    YELLOW='\033[1;33m'
    NC='\033[0m'
}

function set_default_settings {
    N=3
    dir=evaldir;
    PREFIX=$PWD;
    IGNORE_GOLDEN=false
    GNUTIME=/usr/bin/time
}

function error_n_exit {
    show_error "$1";
    exit $2;
}

function show_error {
    >&2 echo -e "${RED}=> ERROR: ${1}${NC}";
}

function show_warning {
    >&2 echo -e "${YELLOW}=> WARNING: ${1}${NC}";
}

function usage {
    echo -e "Usage:	paraevaluar [OPTIONS]... program";
    echo -e "\tOPTIONS:";
    echo -e "\t\t-N|--iterations ITERATIONS\tspecify the number of iterations each binary will be executeds.";
    echo -e "\t\t-i|--ignore-golden\t\tdon't abort when output doesn't match golden output";
    echo -e "\t\t-prefix PREFIX\t\t\tspecify the path of th program (default \$PWD)";
    echo -e "\t\t-d|--directory EVALDIR\t\tsets the paraevaluar working directory to EVALDIR";
    echo -e "\t\t-name NAME\t\t\tsets to the execution the alias NAME";
    echo -e "\t\t-original\t\t\tforces the program to be treated as the original";
    echo -e "\t\t-t|--time-path PATH\t\tto specify the path of time (default /usr/bin/time)";
    echo -e "\t\t-v|--verbose\t\t\tverbose";
    echo -e "\t\t-report [REPORT OPTIONS]\tdisplays the report of the evaluations";
    echo -e "\t\t-o|--output FILE\t\tappends the result of the evaluation to the FILE";
    echo -e "\t\t--clean\t\t\t\tdeletes all evaldir in the current directory";
    echo -e "\t\t-h|--help\t\t\tprint this usage";
    echo -e "\tREPORT OPTIONS:";
    echo -e "\t\tNot implemented yet.";
}

function parse_arguments {
    if [[ $# -eq 0 ]];
    then
        >&2 usage;
        exit 0;
    fi;

    while [[ $# -gt 0 ]] && [[ "$(echo $1 | cut -c-1)" == "-" ]];
    do
        key="$1";
        case $key in
            -N|--iterations)
                N=$2;
                shift; # past argument
                shift; # past value
                ;;
            -i|--ignore-golden)
                IGNORE_GOLDEN=true;
                shift; # past argument
                ;;
            --prefix)
                PREFIX=$2;
                shift; # past argument
                shift; # past value
                ;;
            -d|--directory)
                dir=$2;
                shift; # past argument
                shift; # past value
                ;;
            --name)
                NAME=$2;
                shift; # past argument
                shift; # past value
                ;;
            --original)
                ORIGINAL=true;
                shift; # past argument
                ;;
            -t|--time-path)
                GNUTIME=$2;
                shift # past argument
                shift # past value
                ;;
            -v|--verbose)
                VERBOSE=true;
                shift; # past argument
                ;;
            --report)
                display_table;
                exit 0;
                ;;
            -o|--output)
                OUTPUT=$2;
                shift; # past argument
                shift; # past value
                ;;
            --clean)
                echo -e "=> Cleaning working directory.";
                rm -rf evaldir;
                echo -e "=> Done.";
                exit 0;
                ;;
            -h|--help)
                >&2 usage;
                exit 0;
                ;;
            *)
                show_error "Unknown option: $1";
                >&2 usage;
                exit 1;
                ;;
        esac
    done

    if [ -z ${NAME+x} ]; then NAME=$1; fi;
    PROGRAM=$@;
}

function calculate_values {
	FIRST=true;
	while read line;
	do 
		CUR_E=$(echo ${line}       | awk '{print $1}');
		CUR_P=$(echo ${line//[%]/} | awk '{print "(" $1 "*" $2 ") / 100"}' | bc -l);
		if $FIRST; 
		then
			AVG_E[$2]=$CUR_E;
			MAX_E[$2]=$CUR_E;	
			MIN_E[$2]=$CUR_E;

			AVG_P[$2]=$CUR_P
			MAX_P[$2]=$CUR_P
			MIN_P[$2]=$CUR_P
			FIRST=false;
		else
			if (( $(echo "${MAX_E[${2}]} < ${CUR_E}" |bc -l) )); then MAX_E[$2]=$CUR_E; fi	
			if (( $(echo "${MIN_E[${2}]} > ${CUR_E}" |bc -l) )); then MIN_E[$2]=$CUR_E; fi	
			AVG_E[$2]=$(echo "${CUR_E} + ${AVG_E[${2}]}" |bc -l);

			if (( $(echo "${MAX_P[${2}]} < ${CUR_P}" |bc -l) )); then MAX_P[$2]=$CUR_P; fi	
			if (( $(echo "${MIN_P[${2}]} > ${CUR_P}" |bc -l) )); then MIN_P[$2]=$CUR_P; fi	
			AVG_P[$2]=$(echo "${CUR_P} + ${AVG_P[${2}]}" |bc -l);
		fi
	done < $1;

	AVG_E[$2]=$(echo "${AVG_E[${2}]} / ${N}" | bc -l | awk '{printf("%.4f\n", $1)}');
    if (( $(echo "${AVG_E} <= 0" |bc -l) )); then error_n_exit "That was too quick." 5; fi

	AVG_P[$2]=$(echo "${AVG_P[${2}]} / ${N}" | bc -l | awk '{printf("%.4f\n", $1)}');
    if (( $(echo "${AVG_P} <= 0" |bc -l) )); then error_n_exit "That was too quick." 5; fi
}

function create_table {
    (
    echo ".pl 50";
    echo ".TS H" ;
    echo "allbox, center;";
    echo "l l l l l l l l l.";
    echo ".";
    echo -e "Program\tMaxE\tMinE\tAvgE\tSpeedUpE\tMaxCPU\tMinCPU\tAvgCPU\tSpeedUpCPU"
    echo ".TH";
    ) > $dir/tablefile;

    nu=0;
    while read name;
    do
        if [[ $nu -eq 0 ]];
        then
            calculate_values $dir/$name.time $nu;
            (   
            echo -e -n "$name\t";
            echo -e -n "${MAX_E[${nu}]}\t";
            echo -e -n "${MIN_E[${nu}]}\t";
            echo -e -n "${AVG_E[${nu}]}\t";
            echo -e -n "-\t";
            echo -e -n "${MAX_P[${nu}]}" | awk '{printf("%.2f\t", $1)}';
            echo -e -n "${MIN_P[${nu}]}" | awk '{printf("%.2f\t", $1)}';
            echo -e -n "${AVG_P[${nu}]}\t";
            echo -e    "-\t";
            ) >> $dir/tablefile;
        else
            calculate_values $dir/$name.time $nu;
            (
            echo -e -n "$name\t";
            echo -e -n "${MAX_E[${nu}]}\t";
            echo -e -n "${MIN_E[${nu}]}\t";
            echo -e -n "${AVG_E[${nu}]}\t";
            echo       "${AVG_E[0]} / ${AVG_E[${nu}]}" | bc -l | awk '{printf("%.4f\t", $1)}';
            echo -e -n "${MAX_P[${nu}]}" | awk '{printf("%.4f\t", $1)}';
            echo -e -n "${MIN_P[${nu}]}" | awk '{printf("%.4f\t", $1)}';
            echo -e -n "${AVG_P[${nu}]}\t";
            echo       "${AVG_P[0]} / ${AVG_P[${nu}]}" | bc -l | awk '{printf("%.4f\n", $1)}';
            ) >> $dir/tablefile;
        fi
        nu=$((nu + 1));
    done < $dir/names;

    echo ".TE" >> $dir/tablefile
}

function display_table {
    create_table;
    tbl $dir/tablefile | groff -T ascii 2>/dev/null | awk '{ if (0!=length($0)) print $0}';
    echo -e "\n";
}

# Seting trap for interrupt handling.
trap -- 'error_n_exit "\nInterrupt signal recived" 130' SIGINT;

declare_colors;

set_default_settings;

# Parsing arguments
parse_arguments $@;

# Create dir
if [ -d $dir ];
then
    echo -e "=> Using existent directory.";
    if [ -z ${ORIGINAL+x} ]; then ORIGINAL=false; fi;
else
    ORIGINAL=true;
    echo -e "=> Creating working directory.";
    if mkdir -p $dir;
    then
        touch $dir/names;
    else
        error_n_exit "Failed to create directory." 2;
    fi
fi

UNDER="";
NAME_POST="";
while grep ${NAME}${UNDER}${NAME_POST} $dir/names > /dev/null;
do
    if [ "${NAME_POST}" == "" ];
    then
        UNDER="_";
        NAME_POST=1;
    else
        NAME_POST=$((NAME_POST + 1));
    fi
done

if [ ! "${NAME_POST}" == "" ];
then
    NAME=${NAME}_${NAME_POST};
    show_warning "This name already exists using ${NAME}";
fi

echo $NAME >> $dir/names;

if $ORIGINAL;
then
    echo -e "=> Generating golden output.";
    $PREFIX/$PROGRAM > $dir/golden.out;
    err=$?;
    if [[ $err -eq 130 ]]; then error_n_exit "\nInterrupt signal recived." 130; fi;
    if [[ $err -ne 0 ]];   then error_n_exit "\nProcess ended with exit code: $err."; fi;
else
    echo -e "=> Checking golden output.";
    $PREFIX/$PROGRAM > $dir/$name.out;
    err=$?;
    if [[ $err -eq 130 ]]; then error_n_exit "\nInterrupt signal recived." 130; fi;
    if [[ $err -ne 0 ]];   then error_n_exit "\nProcess ended with exit code: $err."; fi;
    if [[ "$(cat $dir/golden.out | sha256sum )" == "$(cat $dir/$name.out | sha256sum )" ]];
    then
        echo -e "${GREEN}==> Output match.${NC}";
    else    
        if $IGNORE_GOLDEN;
        then
            echo -e "${YELLOW}==> Waring: Output of optimized code number $nu does not match golden output.${NC}"
        else
            echo -e "${RED}==> Error: Output of optimized code number $nu does not match golden output.${NC}"
            error_n_exit "Aborting due to output missmatch" 3;
        fi  
    fi
fi

for i in `seq 1 $N`;
do
    $VERBOSE && echo -e "\t==> Running time test on binary (Iteration $i).";
    /usr/bin/time -f "%e %P" -a -o $dir/$NAME.time $PREFIX/$PROGRAM > $dir/null;
    err=$?;
    if [[ $err -eq 130 ]]; then error_n_exit "\nInterrupt signal recived." 130; fi;
    if [[ $err -ne 0 ]];   then error_n_exit "\nProcess ended with exit code: $err."; fi;
done

