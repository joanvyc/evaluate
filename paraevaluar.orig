#!/bin/bash

<<<<<<< HEAD
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

IGNORE_GOLDEN=false;
VERBOSE=false;
PLOT=false;
NOCLEANUP=false;
N=3
GNUTIME=/usr/bin/time

function show_error {
	>&2 echo -e "${RED}${1}${NC}";
}

function error_n_exit {	
	$NOCLEANUP || echo -e "=> Removing $dir.";
	$NOCLEANUP || rm -rf $dir;
	trap - SIGINT
    show_error "$1";
    exit $2;
}

function pars_args {
	if [ $# -eq 0 ]
		then
			>&2 usage;
			exit 1;
	fi
	
    POSITIONAL=();
	while [[ $# -gt 0 ]] && [[ "$(echo $1 | cut -c-1)" == "-" ]]; 
        do
                key="$1";
                case $key in
			-N)
				N=$2;
				shift # past argument
				shift # past value
				;;
            -i|--ignore-golden)
                IGNORE_GOLDEN=true;
                shift # past argument
                ;;
			-a|--arguments)
				ARGUMENTS="$ARGUMENTS $2";
				shift # past argument
				shift # past value
				;;
			-v|--verbose)
				VERBOSE=true;
				shift # past argument
				;;
			-o|--output)
				OUTPUT=$2;
				shift # past argument
				shift # past value
				;;
			-p|--plot)
				PLOT=true;
				command -v gnuplot >/dev/null || error_n_exit "Error: You are trying to plot data and gnuplot is not installed"
				shift # past argument
				;;
            -t|--time-path)
                GNUTIME="$2"
                shift # past argument
                shift # past value
                ;;
			--no-cleanup)
				NOCLEANUP=true;
				shift # past argument
				;;
			--clean)
				echo -e "=> Cleaning working directory.";
				rm -rf evaldir-*;
				echo -e "=> Done.";
				exit 0;
				shift # past argument
				;;
            -h|--help)
                >&2 usage;
                exit 1;
                ;;
            *)    # unknown option
	     		show_error "Unknown option: $1";
                >&2 usage;
				exit 2;
                ;;
            esac;
        done
	ORIGINAL=$1;
	shift;
	OPTIMIZED=$@;

	if [ ! -f $ORIGINAL ]; then
		error_n_exit "Error: File not found \"${ORIGINAL}\"" 3;
	fi
=======
function declare_colors {
    RED='\033[1;31m'
    GREEN='\033[1;32m'
    YELLOW='\033[1;33m'
    NC='\033[0m'
}

function set_default_settings {
    N=3
    dir=evaldir;
    PREFIX=$PWD;
    IGNORE_GOLDEN=false
    REPORT=false;
    CLEANUP=false;
    GNUTIME=/usr/bin/time
}

function error_n_exit {
    show_error "$1";
    if $CLEANUP;
    then
        if $ORIGINAL;
        then
            rm -rf $dir;
        else
            mv -f $dir/$NAME.out $dir/error.out
            rm -f $dir/$NAME.time;
            sed -i "/\\<$NAME\\>/d" $dir/names;
        fi
    fi
    exit $2;
}
>>>>>>> origin/estalviador

function show_error {
    >&2 echo -e "${RED}=> ERROR: ${1}${NC}";
}

function show_warning {
    >&2 echo -e "${YELLOW}=> WARNING: ${1}${NC}";
}

function usage {
<<<<<<< HEAD
	echo -e "Usage:	paraevaluar [OPTIONS]... original [updated]...";
	echo -e "\tOPTIONS:"
	echo -e "\t\t-h|--help\t\tprint this usage."
	echo -e "\t\t-N ITERATIONS\t\tspecify the number of iterations each binary will be executed."
	echo -e "\t\t-o|--output FILE\tappends the result of the evaluation to the FILE"
	echo -e "\t\t-i|--ignore-golden\tdon't abort when output doesn't match golden output."
    echo -e "\t\t-a|--arguments=ARGUMENT\tappend ARGUMENT to the argument list."
	echo -e "\t\t-p|--plots\t\tplot average time of different versions."
    echo -e "\t\t-t|--time-path\t\tspecify where is the path of GNU/Time(Default:/usr/bin/time)"
	echo -e "\t\t--no-cleanup\t\tkeeps the intermediate files used by the program."
	echo -e "\t\t--clean\t\t\tdeletes all evaldir in the current directory."
}

trap -- 'error_n_exit "\nInterrupt signal received" 130' SIGINT;

pars_args $@;

# Creating working directory
while : ; 
do
	name=$(date '+%F %T' | sha256sum | cut -c-10);
	dir=evaldir-$name;
	echo -e "=> Creating working dir $dir";
	mkdir $dir && break;
	echo -e "${RED}==>Failed to create dir $dir";
done
if [ -z ${OUTPUT+x} ]; then OUTPUT="$dir/output.dat"; fi


# Creating golden outpu
echo -e "=> Generating golden output."
$PWD/$ORIGINAL $ARGUMENTS > $dir/golden.out;
err=$?;
if [[ $err -eq 130 ]]; then error_n_exit "\nInterrupt signal received" 130; fi
if [[ $err -ne 0 ]]; then error_n_exit "The execution of $ORIGINAL finishied with exit code $err" $err; fi


# Runing time tests
START=1
echo -e "=> Running $N time tests on original binary."
for i in `seq $START $N`;
do
	$VERBOSE && echo -e "\t==> Running time test on original binary. (Test $i)";
	$GNUTIME -f "%e %P" -a -o $dir/time_original $PWD/$ORIGINAL $ARGUMENTS > /dev/null;
	if [[ $? -eq 130 ]]; then error_n_exit "\nInterrupt signal received" 130; fi
done

nu=1;
for program in $OPTIMIZED;
do
	echo -e "=> Generating output of optimized binary $nu ($program).";
	$PWD/$program $ARGUMENTS > $dir/optimized_$nu.out;
	if [[ $? -eq 130 ]]; then error_n_exit "\nInterrupt signal received" 130; fi
	echo -e "=> Checking output of optimized binary $nu ($program).";
	if [[ "$(cat $dir/golden.out | sha256sum )" == "$(cat $dir/optimized_$nu.out | sha256sum )" ]];
	then
		echo -e "${GREEN}==> Output match.${NC}";
	else	
		if $IGNORE_GOLDEN;
		then
			echo -e "${YELLOW}==> Waring: Output of optimized code number $nu does not match golden output.${NC}"
		else
			echo -e "${RED}==> Error: Output of optimized code number $nu does not match golden output.${NC}"
			error_n_exit "Aborting due to output missmatch" 3;
		fi
=======
    echo -e "Usage:	paraevaluar [OPTIONS]... program";
    echo -e "\tOPTIONS:";
    echo -e "\t\t-N|--iterations ITERATIONS\tspecify the number of iterations each binary will be executeds.";
    echo -e "\t\t-i|--ignore-golden\t\tdon't abort when output doesn't match golden output";
    echo -e "\t\t-prefix PREFIX\t\t\tspecify the path of th program (default \$PWD)";
    echo -e "\t\t-d|--directory EVALDIR\t\tsets the paraevaluar working directory to EVALDIR";
    echo -e "\t\t-name NAME\t\t\tsets to the execution the alias NAME";
    echo -e "\t\t-original\t\t\tforces the program to be treated as the original";
    echo -e "\t\t-t|--time-path PATH\t\tto specify the path of time (default /usr/bin/time)";
    echo -e "\t\t-v|--verbose\t\t\tverbose";
    echo -e "\t\t-report [REPORT OPTIONS]\tdisplays the report of the evaluations";
    echo -e "\t\t-o|--output FILE\t\tappends the result of the evaluation to the FILE";
    echo -e "\t\t--clean\t\t\t\tdeletes all evaldir in the current directory";
    echo -e "\t\t-h|--help\t\t\tprint this usage";
    echo -e "\tREPORT OPTIONS:";
    echo -e "\t\tNot implemented yet.";
}

function parse_arguments {
    if [[ $# -eq 0 ]];
    then
        >&2 usage;
        exit 0;
    fi;
>>>>>>> origin/estalviador

    while [[ $# -gt 0 ]] && [[ "$(echo $1 | cut -c-1)" == "-" ]];
    do
        key="$1";
        case $key in
            -N|--iterations)
                N=$2;
                shift; # past argument
                shift; # past value
                ;;
            -i|--ignore-golden)
                IGNORE_GOLDEN=true;
                shift; # past argument
                ;;
            --prefix)
                PREFIX=$2;
                shift; # past argument
                shift; # past value
                ;;
            -d|--directory)
                dir=$2;
                shift; # past argument
                shift; # past value
                ;;
            --name)
                NAME=$2;
                shift; # past argument
                shift; # past value
                ;;
            --original)
                ORIGINAL=true;
                shift; # past argument
                ;;
            -t|--time-path)
                GNUTIME=$2;
                shift # past argument
                shift # past value
                ;;
            -v|--verbose)
                VERBOSE=true;
                shift; # past argument
                ;;
            --report)
                REPORT=true;
                shift; # past argument
                ;;
            -o|--output)
                OUTPUT=$2;
                shift; # past argument
                shift; # past value
                ;;
            --clean-all)
                echo -e "=> Cleaning working directory.";
                rm -rf $dir;
                echo -e "=> Done.";
                exit 0;
                ;;
            --clean)
                NAME=$2;
                ORIGINAL=false
                CLEANUP=true
                error_n_exit "Deleting $2 entry." 0
                ;;
            -h|--help)
                >&2 usage;
                exit 0;
                ;;
            *)
                show_error "Unknown option: $1";
                >&2 usage;
                exit 1;
                ;;
        esac
    done

<<<<<<< HEAD
    echo -e "=> Running $N time tests on original binary.";
	for i in `seq $START $N`;
	do
		$VERBOSE && echo -e "\t==> Running time test on optimized binary $nu. (Test $i)";
		$GNUTIME -f "%e %P" -a -o $dir/time_update_$nu $PWD/$program $ARGUMENTS > /dev/null;
		if [[ $? -eq 130 ]]; then error_n_exit "\nInterrupt signal received" 130; fi
	done
	nu=$((nu + 1));
done
=======
    if [ -z ${NAME+x} ]; then NAME=$1; fi;
    if [ -z ${OUTPUT+x} ]; then OUTPUT=$dir/output; fi;
    PROGRAM=$@;
}
>>>>>>> origin/estalviador

function calculate_values {
	FIRST=true;
  lines=0;
	while read line;
	do
		CUR_E=$(echo ${line} | awk '{print $1}');
		CUR_P=$(echo ${line} | cut -d % -f 1 | awk '{print "(" $1 "*" $2 ") / 100"}' | bc -l);
		if $FIRST;
		then
			AVG_E[$2]=$CUR_E;
			MAX_E[$2]=$CUR_E;
			MIN_E[$2]=$CUR_E;

			AVG_P[$2]=$CUR_P
			MAX_P[$2]=$CUR_P
			MIN_P[$2]=$CUR_P
			FIRST=false;
		else
			if (( $(echo "${MAX_E[${2}]} < ${CUR_E}" |bc -l) )); then MAX_E[$2]=$CUR_E; fi;
			if (( $(echo "${MIN_E[${2}]} > ${CUR_E}" |bc -l) )); then MIN_E[$2]=$CUR_E; fi;
			AVG_E[$2]=$(echo "${CUR_E} + ${AVG_E[${2}]}" |bc -l);

			if (( $(echo "${MAX_P[${2}]} < ${CUR_P}" |bc -l) )); then MAX_P[$2]=$CUR_P; fi;
			if (( $(echo "${MIN_P[${2}]} > ${CUR_P}" |bc -l) )); then MIN_P[$2]=$CUR_P; fi;
			AVG_P[$2]=$(echo "${CUR_P} + ${AVG_P[${2}]}" |bc -l);
		fi
    lines=$((lines + 1));
	done < $1;

	AVG_E[$2]=$(echo "${AVG_E[${2}]} / ${lines}" | bc -l | awk '{printf("%.4f\n", $1)}');
    CLEANUP=false;
    if (( $(echo "${AVG_E} <= 0" |bc -l) )); then error_n_exit "That was too quick." 5; fi

	AVG_P[$2]=$(echo "${AVG_P[${2}]} / ${lines}" | bc -l | awk '{printf("%.4f\n", $1)}');
    CLEANUP=false;
    if (( $(echo "${AVG_P} <= 0" |bc -l) )); then error_n_exit "That was too quick." 5; fi
}

function create_table {
    (
    echo ".pl 50";
    echo ".TS H" ;
    echo "allbox, center;";
    echo "l l l l l l l l l.";
    echo ".";
    echo -e "Program\tMaxE (s)\tMinE (s)\tAvgE (s)\tSpeedUpE\tMaxCPU (s)\tMinCPU (s)\tAvgCPU (s)\tSpeedUpCPU"
    echo ".TH";
    ) > $dir/tablefile;

    nu=0;
    while read name;
    do
        if [[ $nu -eq 0 ]];
        then
            calculate_values $dir/$name.time $nu;
            (
            echo -e -n "$name\t";
            echo -e -n "${MAX_E[${nu}]}\t";
            echo -e -n "${MIN_E[${nu}]}\t";
            echo -e -n "${AVG_E[${nu}]}\t";
            echo -e -n "-\t";
            echo -e -n "${MAX_P[${nu}]}" | awk '{printf("%.2f\t", $1)}';
            echo -e -n "${MIN_P[${nu}]}" | awk '{printf("%.2f\t", $1)}';
            echo -e -n "${AVG_P[${nu}]}\t";
            echo -e    "-\t";
            ) >> $dir/tablefile;
        else
            calculate_values $dir/$name.time $nu;
            (
            echo -e -n "$name\t";
            echo -e -n "${MAX_E[${nu}]}\t";
            echo -e -n "${MIN_E[${nu}]}\t";
            echo -e -n "${AVG_E[${nu}]}\t";
            echo       "${AVG_E[0]} / ${AVG_E[${nu}]}" | bc -l | awk '{printf("%.4f\t", $1)}';
            echo -e -n "${MAX_P[${nu}]}" | awk '{printf("%.4f\t", $1)}';
            echo -e -n "${MIN_P[${nu}]}" | awk '{printf("%.4f\t", $1)}';
            echo -e -n "${AVG_P[${nu}]}\t";
            echo       "${AVG_P[0]} / ${AVG_P[${nu}]}" | bc -l | awk '{printf("%.4f\n", $1)}';
            ) >> $dir/tablefile;
        fi
        nu=$((nu + 1));
    done < $dir/names;

    echo ".TE" >> $dir/tablefile
}

function display_table {
    create_table;
    tbl $dir/tablefile | groff -T ascii 2>/dev/null | awk '{ if (0!=length($0)) print $0}' | tee --append $OUTPUT;
    echo -e "\n";
    echo -e "\n" >> $OUTPUT;
}

# Seting trap for interrupt handling.
trap -- 'CLEANUP=true; error_n_exit "\nInterrupt signal recived" 130' SIGINT;

declare_colors;

set_default_settings;

# Parsing arguments
parse_arguments $@;
PATH=$PREFIX:$PATH;

if $REPORT;
then
    display_table;
    exit 0;
fi;

if ! which $(echo $PROGRAM | cut -d ' ' -f 1) 2>&1 > /dev/null;
then
    error_n_exit "$PROGRAM does not exists." 6;
fi

# Create dir
if [ -d $dir ];
then
    echo -e "=> Using existent directory.";
    if [ -z ${ORIGINAL+x} ]; then ORIGINAL=false; fi;
else
    ORIGINAL=true;
    echo -e "=> Creating working directory.";
    if mkdir -p $dir;
    then
        touch $dir/names;
    else
        CLEANUP=true
        error_n_exit "Failed to create directory." 2;
    fi
fi

UNDER="";
NAME_POST="";
while grep ${NAME}${UNDER}${NAME_POST} $dir/names > /dev/null;
do
    if [ "${NAME_POST}" == "" ];
    then
        UNDER="_";
        NAME_POST=1;
    else
        NAME_POST=$((NAME_POST + 1));
    fi
done

if [ ! "${NAME_POST}" == "" ];
then
    NAME=${NAME}_${NAME_POST};
    show_warning "This name already exists using ${NAME}";
fi

if $ORIGINAL;
then
    mv $dir/names $dir/names.back
    echo -e "$NAME" > $dir/names;
    cat $dir/names.back >> $dir/names;
    rm -f $dir/names.back;
else
    echo $NAME >> $dir/names;
fi

if $ORIGINAL;
then
    echo -e "=> Generating golden output.";
    $PROGRAM > $dir/golden.out;
    err=$?;
    CLEANUP=true;
    if [[ $err -eq 130 ]]; then error_n_exit "\nInterrupt signal recived." 130; fi;
    if [[ $err -ne 0 ]];   then error_n_exit "\nProcess ended with exit code: $err."; fi;
    cp $dir/golden.out $dir/$NAME.out;
else
    echo -e "=> Checking golden output.";
    $PROGRAM > $dir/$NAME.out;
    err=$?;
    CLEANUP=true;
    if [[ $err -eq 130 ]]; then error_n_exit "\nInterrupt signal recived." 130; fi;
    if [[ $err -ne 0 ]];   then error_n_exit "\nProcess ended with exit code: $err."; fi;
    if [[ "$(cat $dir/golden.out | sha256sum )" == "$(cat $dir/$NAME.out | sha256sum )" ]];
    then
        echo -e "${GREEN}==> Output match.${NC}";
    else
        if $IGNORE_GOLDEN;
        then
            show_warning "Output of $NAME does not match golden output.";
        else
            show_error "Output of $NAME does not match golden output.";
            CLEANUP=true;
            error_n_exit "Aborting due to output missmatch" 3;
        fi
    fi
fi

for i in `seq 1 $N`;
do
    $VERBOSE && echo -e "\t==> Running time test on binary (Iteration $i).";
    /usr/bin/time -f "%e %P" -a -o $dir/$NAME.time $PROGRAM > $dir/null;
    err=$?;
    if [[ $err -eq 130 ]]; then error_n_exit "\nInterrupt signal recived." 130; fi;
    if [[ $err -ne 0 ]];   then error_n_exit "\nProcess ended with exit code: $err."; fi;
done

